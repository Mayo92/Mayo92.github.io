<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
  <title>妙妙屋</title>
  <link rel="shortcut icon" href="/images/favicon.ico"> 
<link rel="stylesheet" href="/css/style.css">
 
<script src="/js/jquery.js"></script>
 
<script src="/js/search.js"></script>

<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <article class="article-container">
  <section class="header-container">
  <a class="header-title" href="/">
    <svg t="1693387181307" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4053" width="20" height="20">
      <path d="M946.5 505L560.1 118.8l-25.9-25.9c-12.3-12.2-32.1-12.2-44.4 0L77.5 505c-12.3 12.3-18.9 28.6-18.8 46 0.4 35.2 29.7 63.3 64.9 63.3h42.5V940h691.8V614.3h43.4c17.1 0 33.2-6.7 45.3-18.8 12.1-12.1 18.7-28.2 18.7-45.3 0-17-6.7-33.1-18.8-45.2zM568 868H456V664h112v204z m217.9-325.7V868H632V640c0-22.1-17.9-40-40-40H432c-22.1 0-40 17.9-40 40v228H238.1V542.3h-96l370-369.7 23.1 23.1L882 542.3h-96.1z" p-id="4054" fill="#515151"></path>
    </svg>
    <span>妙妙屋</span>
  </a>
</section>
  <section class="article-body">
    <div class="post-toc">
      <h3>本文目录</h3>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1. 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">2. Android多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">2.1 线程的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F%E8%80%A6%E5%90%88%E5%BA%A6%E6%9C%89%E7%82%B9%E9%AB%98"><span class="toc-text">2.1.1 继承的方式耦合度有点高</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-Thread%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%8E%A5%E6%94%B6%E4%B8%80%E4%B8%AARunnable%E5%8F%82%E6%95%B0%EF%BC%8CmyThread%E6%AD%A3%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E4%BA%86Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.1.2 Thread的构造函数接收一个Runnable参数，myThread正是一个实现了Runnable接口的对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-text">2.1.3 匿名类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%9B%B4%E6%96%B0UI"><span class="toc-text">2.2 在子线程中更新UI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%A7%A3%E6%9E%90%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3 解析异步消息处理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E4%BD%BF%E7%94%A8AsyncTask"><span class="toc-text">2.4 使用AsyncTask</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E9%87%8D%E5%86%994%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-text">需重写4个方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#onPreExecute"><span class="toc-text">onPreExecute():</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doInBackground-Params%E2%80%A6"><span class="toc-text">doInBackground(Params…):</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#onProgressUpdate-Progress%E2%80%A6"><span class="toc-text">onProgressUpdate(Progress…):</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#onPostExecute-Result"><span class="toc-text">onPostExecute(Result):</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">3. 服务的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.1 定义一个服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.2 启动和停止服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%B4%BB%E5%8A%A8%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1-onBind"><span class="toc-text">3.3 活动和服务进行通信 onBind()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E7%A4%BA%E4%BE%8B"><span class="toc-text">下载示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Activity%E4%BB%A3%E7%A0%81"><span class="toc-text">Activity代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4. 服务的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#startService-%E6%96%B9%E6%B3%95"><span class="toc-text">startService()方法:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bindService-%E6%96%B9%E6%B3%95"><span class="toc-text">bindService()方法:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B3%E8%B0%83%E7%94%A8%E4%BA%86startService-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8F%88%E8%B0%83%E7%94%A8%E4%BA%86bindService-%E6%96%B9%E6%B3%95"><span class="toc-text">即调用了startService()方法，又调用了bindService()方法:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%8A%80%E5%B7%A7"><span class="toc-text">5. 服务的更多技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BD%BF%E7%94%A8%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1"><span class="toc-text">5.1 使用前台服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BD%BF%E7%94%A8IntentService"><span class="toc-text">5.2 使用IntentService</span></a></li></ol></li></ol>
    </div>
    <div class="post-container">
      <div class="post-title">
        <h2 class="title">
          第一行代码笔记-Service
        </h2>
      </div>
      <div class="post-meta">
      </div>
      <div class="post-content">
        <h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h3><p>是Android实现程序后台运行的解决方案，适合执行那些不需要和用户交互且还要长期运行的项目。不依赖任何用户界面，即使切换到后台或打开另一个程序，服务仍然能够正常运行。当应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。默认运行在主线程中。</p>
<span id="more"></span>

<h3 id="2-Android多线程编程"><a href="#2-Android多线程编程" class="headerlink" title="2. Android多线程编程"></a>2. Android多线程编程</h3><h4 id="2-1-线程的基本用法"><a href="#2-1-线程的基本用法" class="headerlink" title="2.1 线程的基本用法"></a>2.1 线程的基本用法</h4><h5 id="2-1-1-继承的方式耦合度有点高"><a href="#2-1-1-继承的方式耦合度有点高" class="headerlink" title="2.1.1 继承的方式耦合度有点高"></a>2.1.1 继承的方式耦合度有点高</h5><pre><code>class MyThread extends Thread &#123;
    
    @Override
    public void run() &#123;
        
    &#125;
&#125;

new MyThread().start();
</code></pre>
<h5 id="2-1-2-Thread的构造函数接收一个Runnable参数，myThread正是一个实现了Runnable接口的对象"><a href="#2-1-2-Thread的构造函数接收一个Runnable参数，myThread正是一个实现了Runnable接口的对象" class="headerlink" title="2.1.2 Thread的构造函数接收一个Runnable参数，myThread正是一个实现了Runnable接口的对象"></a>2.1.2 Thread的构造函数接收一个Runnable参数，myThread正是一个实现了Runnable接口的对象</h5><pre><code>class MyThread implements Runnable &#123;
    
    @Override
    public void run() &#123;
        
    &#125;
&#125;

MyThread myThread = new MyThread();
new Thread(myThread).start();
</code></pre>
<h5 id="2-1-3-匿名类"><a href="#2-1-3-匿名类" class="headerlink" title="2.1.3 匿名类"></a>2.1.3 匿名类</h5><pre><code>new Thread(new Runnable()&#123;
    
    @Override
    public void run() &#123;
        
    &#125;
&#125;).start();
</code></pre>
<h4 id="2-2-在子线程中更新UI"><a href="#2-2-在子线程中更新UI" class="headerlink" title="2.2 在子线程中更新UI"></a>2.2 在子线程中更新UI</h4><pre><code>public static final int UPDATE_TEXT = 1;

private Handler handler = new Handler() &#123;

    public void handleMessage(Message msg)&#123;
        switch(msg.what) &#123;
            case UPDATE_TEXT:
                //更新UI
                break;
            default:
                break;
        &#125;
    &#125;
&#125;;

Message message = new Message();
message.what = UPDATE_TEXT;
handler.sendMessage(message);
</code></pre>
<h4 id="2-3-解析异步消息处理机制"><a href="#2-3-解析异步消息处理机制" class="headerlink" title="2.3 解析异步消息处理机制"></a>2.3 解析异步消息处理机制</h4><p>Message是在线程之间传递的消息，可以在内部携带少量的信息，用于不同线程之间交换数据。除了使用what，还可以使用arg1和arg2字段来携带一些整数据，使用obj字段携带一个Object对象。</p>
<p>handler主要用于发送消息和处理消息。使用sendMessage()后，最终传递到handleMessage()方法中。</p>
<p>MessageQueue消息队列，主要用于存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。</p>
<p>Looper是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入一个无限循环中，每当发现一个MessageQueue中存在一条消息就会将它取出，并传递到Handler的handleMessage()方法中。每个线程只有一个Looper对象。</p>
<p><img src="/2018/03/16/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0-Service/1.png"></p>
<p>runOnUiThread()方法其实是一个异步消息处理机制的接口封装，背后原理一致。</p>
<h4 id="2-4-使用AsyncTask"><a href="#2-4-使用AsyncTask" class="headerlink" title="2.4 使用AsyncTask"></a>2.4 使用AsyncTask</h4><p>AsyncTask是一个抽象类，如果我们想使用它就必须创建一个类继承它，需指定3个泛型参数</p>
<ul>
<li><p>Params，执行AsyncTask时需要传入的参数，可用于在后台任务中使用</p>
</li>
<li><p>Progress，后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位</p>
</li>
<li><p>Result，当任务执行完毕之后，需要对结果进行返回，则使用这里指定的泛型作为返回值类型</p>
<p>  class DownloadTask extends AsyncTask&lt;Void,Integer,Boolean&gt; {<br>  }</p>
</li>
</ul>
<p>第一个指定为Void表示执行AsyncTask的时候不需要传入参数给后台任务。第二个指定为Integer，表示使用整形数据作为进度显示单位。第三个指定为Boolean，表示使用布尔类型数据来反馈执行结果。</p>
<h5 id="需重写4个方法"><a href="#需重写4个方法" class="headerlink" title="需重写4个方法"></a>需重写4个方法</h5><h5 id="onPreExecute"><a href="#onPreExecute" class="headerlink" title="onPreExecute():"></a>onPreExecute():</h5><p>在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，如显示进度条对话框等</p>
<h5 id="doInBackground-Params…"><a href="#doInBackground-Params…" class="headerlink" title="doInBackground(Params…):"></a>doInBackground(Params…):</h5><p>所有代码都在子线程中运行，在这里处理所有耗时任务。任务一旦完成通过return语句将任务的执行结果返回。如果AsyncTask的第三个泛型参数为Void，则可以不返回任务执行的结果。这个方法不可以进行UI操作，如果需要更新UI如反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。</p>
<h5 id="onProgressUpdate-Progress…"><a href="#onProgressUpdate-Progress…" class="headerlink" title="onProgressUpdate(Progress…):"></a>onProgressUpdate(Progress…):</h5><p>当调用了publishProgress(Progress…)后，这个方法会很快被调用，该方法携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数的数值可以对界面元素进行相应的更新。</p>
<h5 id="onPostExecute-Result"><a href="#onPostExecute-Result" class="headerlink" title="onPostExecute(Result):"></a>onPostExecute(Result):</h5><p>当后台任务执行完毕并通过return语句返回时，这个方法很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，如提醒任务执行结果，以及关闭进度条等。</p>
<pre><code>class DownloadTask extends AsyncTask&lt;Void,Integer,Boolean&gt; &#123;

    @Override
    protected void onPreExecute() &#123;
        progressDialog.show();
    &#125;
    
    @Override
    protected Boolean doInBackground(Void... params) &#123;
        try &#123;
            while(true) &#123;
                int downloadPercent = doDownload();
                publishProgress(downloadPercent);
                if(downloadPercent &gt;= 100) &#123;
                    break;
                &#125;
            &#125;
        &#125; catch (Exception e)&#123;
            return false;
        &#125;
        return true;
    &#125;
    
    @Override
    protected void onProgressUpdate(Integer... values) &#123;
        //更新下载进度
        progressDialog.setMessage(&quot;Download&quot; + values[0] + &quot;%&quot;);
    &#125;
    
    @Override
    protected void onPostExecute(Boolean result) &#123;
        progressDialog.dismiss();
        //下载结果
        if(result)&#123;
        &#125;else &#123;
        &#125;
    &#125;
&#125;

new DownloadTask().execute();
</code></pre>
<h3 id="3-服务的基本用法"><a href="#3-服务的基本用法" class="headerlink" title="3. 服务的基本用法"></a>3. 服务的基本用法</h3><h4 id="3-1-定义一个服务"><a href="#3-1-定义一个服务" class="headerlink" title="3.1 定义一个服务"></a>3.1 定义一个服务</h4><p>manifest中Exported表示是否允许除了当前应用之外的其他应用访问这个服务，Enabled表示是否启动这个服务。onBind()是唯一的抽象方法必须实现。</p>
<pre><code>public class MyService extends Service &#123;
    
    public MyService()&#123;
    &#125;
    
    @Override
    public IBinder onBind(Intent intent) &#123;
        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);
    &#125; 
    
    @Override
    public void onCreate() &#123;
        super. onCreate();
    &#125;
    
    @Override
    public void onStartCommand(Intent intent,int flags,int startId) &#123;
        return super. onStartCommand(intent, flags, startId);
    &#125;
    
    @Override
    public void onDestroy() &#123;
        super. onDestroy();
    &#125;
&#125;
</code></pre>
<p>onCreate服务创建的时候调用，onStartCommand每次服务启动的时候调用，多次启动服务只有onStartCommand会执行。onDestroy服务销毁的时候调用。</p>
<h4 id="3-2-启动和停止服务"><a href="#3-2-启动和停止服务" class="headerlink" title="3.2 启动和停止服务"></a>3.2 启动和停止服务</h4><pre><code>Intent startIntent = new Intent(this, MyService.class);
startService(startIntent);

Intent stopIntent = new Intent(this,MyService.class);
stopService(stopIntent);
</code></pre>
<p>这是通过Activity来决定服务何时停止的，如果没有执行停止服务会一直处于运行状态。也可以在MyService的任一位置调用stopSelf()停止这个服务。</p>
<h4 id="3-3-活动和服务进行通信-onBind"><a href="#3-3-活动和服务进行通信-onBind" class="headerlink" title="3.3 活动和服务进行通信 onBind()"></a>3.3 活动和服务进行通信 onBind()</h4><h5 id="下载示例"><a href="#下载示例" class="headerlink" title="下载示例"></a>下载示例</h5><pre><code>public class MyService extends Service &#123;

    private DownloadBinder mBinder = new DownloadBinder();
    
    class DownloadBinder extends Binder &#123;
    
        public void startDownload() &#123;
        &#125;
        
        public int getProgress() &#123;
            return 0;
        &#125;
    &#125;
    
    public MyService()&#123;
    &#125;
    
    @Override
    public IBinder onBind(Intent intent) &#123;
        return mBinder;
    &#125; 
    
    @Override
    public void onCreate() &#123;
        super. onCreate();
    &#125;
    
    @Override
    public void onStartCommand(Intent intent,int flags,int startId) &#123;
        return super. onStartCommand(intent, flags, startId);
    &#125;
    
    @Override
    public void onDestroy() &#123;
        super. onDestroy();
    &#125;
&#125;
</code></pre>
<h5 id="Activity代码"><a href="#Activity代码" class="headerlink" title="Activity代码"></a>Activity代码</h5><pre><code>private MyService.DownloadBinder downloadBinder;

//绑定服务
Intent bindIntent = new Intent(this,MyService.class);
bindService(bindIntent,connection,BIND_AUTO_CREATE);

//解绑服务
unbindService(connection);

private ServiceConnection connection = new ServiceConnection() &#123;

    @Override
    public void onServiceDisconnected(ComponentName name) &#123;
    &#125;
    
    @Override
    public void onServiceConnected(ComponentName name,IBinder service&#123;
        downloadBinder = (MyService.DownloadBinder)service;
        downloadBinder.startDownload();
        downloadBinder.getProgress();
    &#125;
&#125;；
</code></pre>
<p>BIND_AUTO_CREATE表示活动和服务进行绑定后自动创建服务，这会使得onCreate()方法执行，而onStartCommand()方法不执行。任何一个服务在整个应用程序范围内是通用的，即一个服务可以与多个Activity绑定，得到相同的DownloadBinder实例。</p>
<h3 id="4-服务的生命周期"><a href="#4-服务的生命周期" class="headerlink" title="4. 服务的生命周期"></a>4. 服务的生命周期</h3><h5 id="startService-方法"><a href="#startService-方法" class="headerlink" title="startService()方法:"></a>startService()方法:</h5><p>回调onStartCommand()方法，如果没有创建过，onCreate()方法会先于onStartCommand()方法执行。之后一直运行，知道调用stopService()或者stopSelf()。不管调用多少次startService()，停止只需一次，调用onDestroy()方法。</p>
<h5 id="bindService-方法"><a href="#bindService-方法" class="headerlink" title="bindService()方法:"></a>bindService()方法:</h5><p>回调onBind()方法，如果服务没有创建过，先执行onCreate()方法。调用方和服务之间的连接没有断开，服务就会一直执行。调用unbindeService()方法回调onDestroy()方法。</p>
<h5 id="即调用了startService-方法，又调用了bindService-方法"><a href="#即调用了startService-方法，又调用了bindService-方法" class="headerlink" title="即调用了startService()方法，又调用了bindService()方法:"></a>即调用了startService()方法，又调用了bindService()方法:</h5><p>销毁时需要调用stopService()和unbindeService()，onDestroy()才会执行。</p>
<h3 id="5-服务的更多技巧"><a href="#5-服务的更多技巧" class="headerlink" title="5. 服务的更多技巧"></a>5. 服务的更多技巧</h3><h4 id="5-1-使用前台服务"><a href="#5-1-使用前台服务" class="headerlink" title="5.1 使用前台服务"></a>5.1 使用前台服务</h4><p>当系统内存不足的时候，就可能会回收掉正在后台运行的服务，这时可以考虑前台服务。</p>
<pre><code>public class MyService extends Service &#123;
    
    @Override
    public void onCreate() &#123;
        super. onCreate();
        Intent intent = new Intent(this,MainActivity.class);
        PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);
        Notification notification = new NotificationCompat.Builder(this)
            .setContentTitle(&quot;xxx&quot;)
            .setContentText(&quot;xxx&quot;)
            .setWhen(System.currentTimeMillis())
            .setSmallIcon(R.mipmap.xxx)
            .setLargeIcon(BitmapFactory.decodeResource(getResource(),
                R.mipmap.xxx))
            .setContentIntent(pi)
            .builder();
        startForeground(1, notification);
    &#125;
    ...
&#125;
</code></pre>
<p>构建出Notification对象后并没有使用NotificationManager来将通知显示出来，而是调用了startForeground()方法，接收两个参数，第一个是id，第二个是Notification对象。</p>
<h4 id="5-2-使用IntentService"><a href="#5-2-使用IntentService" class="headerlink" title="5.2 使用IntentService"></a>5.2 使用IntentService</h4><p>一个异步的、会自动停止的服务。</p>
<pre><code>public class MyIntentService extends IntentService &#123;
    
    public MyIntentService()&#123;
        //调用父类的有参构造函数
        super(&quot;MyIntentService&quot;);
    &#125;
    
    @Override
    public void onHandleIntent(Intent intent) &#123;
        
    &#125;
    
    @Override
    public void onDestroy() &#123;
        super. onDestroy();
    &#125;
&#125;
</code></pre>
<p>首先提供一个无参的构造函数，且必须在内部调用父类的有参构造函数。在子类实现onHandleIntent()这个抽象方法，这个方法中处理一些具体的逻辑且不用担心ANR问题。服务结束后自动停止。</p>

      </div>
    </div>
  </section>
</article>
<!-- go-top -->
<a id="goTop" class="go-top" type="button">
  <svg t="1693380723883" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3999" width="20" height="20">
    <path d="M825.568 555.328l-287.392-289.28C531.808 259.648 523.488 256.576 515.2 256.64 514.08 256.544 513.12 256 512 256c-4.672 0-9.024 1.088-13.024 2.88-4.032 1.536-7.872 3.872-11.136 7.136l-259.328 258.88c-12.512 12.48-12.544 32.736-0.032 45.248 6.24 6.272 14.432 9.408 22.656 9.408 8.192 0 16.352-3.136 22.624-9.344L480 364.288 480 928c0 17.696 14.336 32 32 32s32-14.304 32-32L544 362.72l236.192 237.728c6.24 6.272 14.496 9.44 22.688 9.44s16.32-3.104 22.56-9.312C838.016 588.128 838.048 567.84 825.568 555.328zM864 192 160 192C142.336 192 128 177.664 128 160s14.336-32 32-32l704 0c17.696 0 32 14.336 32 32S881.696 192 864 192z" fill="#ffffff" p-id="4000"></path>
  </svg>
</a>
<script>
  goTop.addEventListener('click', function(e) {
    document.querySelector('.post-container').scrollTo({
      top: 0,
      left: 0,
      behavior: "smooth",
    });
  });
</script>
</body>

</html>